<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Setup — Create shareable package</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:20px;max-width:900px}
    .thumb{max-width:220px;display:block;margin:8px 0}
    .warning{color:#b00}
    textarea{width:100%;height:140px}
    input[type=file]{display:block;margin-bottom:8px}
  </style>
</head>
<body>
  <h1>Create shareable link (client-side only)</h1>
  <p>Upload images and optional audio. Assets are encoded into the generated link. No uploads to third parties.</p>

  <label>Images (multiple allowed):
    <input id="images" type="file" accept="image/*" multiple>
  </label>

  <label>Audio (optional, multiple allowed):
    <input id="audios" type="file" accept="audio/*" multiple>
  </label>

  <label>Max image width (px):
    <input id="maxw" type="number" value="1200" min="200" />
  </label>

  <label>Image quality (0.1 - 1):
    <input id="quality" type="number" step="0.1" value="0.8" min="0.1" max="1" />
  </label>

  <p><button id="make">Create shareable link</button></p>

  <div id="preview"></div>

  <h3>Shareable link</h3>
  <textarea id="link" placeholder="Generated link shows here"></textarea>
  <p class="warning" id="warn"></p>

  <script src="https://unpkg.com/lz-string/libs/lz-string.min.js"></script>
  <script>
    // Helper: read file as ArrayBuffer
    function readFileAsArrayBuffer(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsArrayBuffer(file); }); }
    // Helper: read file as DataURL
    function readFileAsDataURL(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsDataURL(file); }); }

    // Resize image via canvas and return dataURL (WebP)
    async function resizeImage(file, maxWidth, quality){
      const url = URL.createObjectURL(file);
      const img = await new Promise((res,rej)=>{
        const el = new Image();
        el.onload = ()=>res(el);
        el.onerror = rej;
        el.src = url;
      });
      URL.revokeObjectURL(url);
      const scale = Math.min(1, maxWidth / img.width);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      // toDataURL may be synchronous for some browsers; we use toBlob to control quality
      return new Promise((res)=> {
        canvas.toBlob(blob => {
          const fr = new FileReader();
          fr.onload = ()=>res(fr.result); // dataURL
          fr.readAsDataURL(blob);
        }, 'image/webp', quality);
      });
    }

    document.getElementById('make').addEventListener('click', async ()=>{
      const images = Array.from(document.getElementById('images').files || []);
      const audios = Array.from(document.getElementById('audios').files || []);
      const maxw = parseInt(document.getElementById('maxw').value) || 1200;
      const quality = parseFloat(document.getElementById('quality').value) || 0.8;

      const preview = document.getElementById('preview');
      preview.innerHTML = '<p>Processing…</p>';
      const packageObj = {images: [], audios: []};

      // Process images: resize -> dataURL
      for (const f of images){
        try{
          const dataURL = await resizeImage(f, maxw, quality);
          packageObj.images.push({name: f.name, type: f.type, data: dataURL});
        }catch(e){
          console.error('image process failed', e);
        }
      }

      // Process audios: read as dataURL (note: audio files can be big)
      for (const f of audios){
        try{
          const dataURL = await readFileAsDataURL(f);
          packageObj.audios.push({name: f.name, type: f.type, data: dataURL});
        }catch(e){
          console.error('audio process failed', e);
        }
      }

      // Stringify and compress (LZ-String)
      const json = JSON.stringify(packageObj);
      // compress to encoded URI component (URL-safe)
      const payload = LZString.compressToEncodedURIComponent(json);

      // Compose shareable URL: put in fragment so it is never sent to servers during HTTP requests
      const origin = location.origin + location.pathname.replace(/setup\.html$/,'').replace(/\/$/,'') + '/';
      // If your view page is view.html in same folder:
      const viewPath = origin + 'view.html#d=' + payload;
      document.getElementById('link').value = viewPath;

      // Show preview thumbnails
      preview.innerHTML = '';
      for (const im of packageObj.images){
        const imgEl = document.createElement('img');
        imgEl.src = im.data;
        imgEl.className = 'thumb';
        preview.appendChild(imgEl);
      }
      for (const au of packageObj.audios){
        const aEl = document.createElement('audio');
        aEl.controls = true;
        aEl.src = au.data;
        preview.appendChild(aEl);
      }

      // Warn about size
      const warn = document.getElementById('warn');
      const approxLen = payload.length;
      if (approxLen > 20000){
        warn.textContent = 'Warning: payload is large ('+Math.round(approxLen/1024)+' KB). Very long URLs may be truncated by some apps. Consider reducing image dimensions or quality.';
      } else {
        warn.textContent = '';
      }
    });
  </script>
</body>
</html>
