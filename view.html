<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>View shared assets</title>
  <style>
    body{font-family:system-ui,Arial;margin:20px;max-width:960px}
    img{max-width:100%;height:auto;margin:8px 0}
    .item{margin-bottom:12px}
    .meta{font-size:0.9rem;color:#555}
  </style>
</head>
<body>
  <h1>Shared assets</h1>
  <div id="content">Loadingâ€¦</div>

  <script>
    function qsParam(name){
      const params = new URLSearchParams(location.search);
      return params.get(name);
    }

    // Try to construct a raw.githubusercontent URL for the share JSON.
    // This tends to reflect commits immediately and avoids GitHub Pages publish delay.
    function constructRawShareUrl(id){
      try {
        // If page is served as https://<owner>.github.io/<repo>/..., infer owner and repo
        const hostParts = location.hostname.split('.');
        const pathParts = location.pathname.split('/').filter(Boolean); // remove empty parts
        if (hostParts.length >= 3 && hostParts[1] === 'github' && hostParts[2] === 'io' && pathParts.length >= 1) {
          const owner = hostParts[0];
          const repo = pathParts[0];
          const branch = 'main'; // change if you use a different branch
          return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/shares/${id}.json`;
        }
      } catch (e) {
        // fall back to relative path below
      }
      // Fallback: relative path served by GitHub Pages
      return `./shares/${id}.json`;
    }

    (async function(){
      const content = document.getElementById('content');
      const id = qsParam('share');
      if (!id) { content.innerHTML = '<p>No share id.</p>'; return; }

      // first try raw.githubusercontent (fast), then fallback to Pages path if that fails
      const rawUrl = constructRawShareUrl(id);
      const candidateUrls = [rawUrl];
      // if rawUrl is already relative pages path, candidateUrls is fine; otherwise add the ./shares fallback too
      if (!rawUrl.startsWith('https://raw.githubusercontent.com')) candidateUrls.push(`./shares/${id}.json`);
      else candidateUrls.push(`./shares/${id}.json`);

      let share = null;
      for (const url of candidateUrls){
        try {
          const resp = await fetch(url);
          if (!resp.ok) {
            // try next candidate
            continue;
          }
          share = await resp.json();
          break;
        } catch (err) {
          // try next
          continue;
        }
      }

      if (!share) {
        content.innerHTML = '<p>Share not found yet. Please try again in a minute or refresh.</p>';
        return;
      }

      content.innerHTML = '';
      if (share.files && share.files.length) {
        for (const f of share.files) {
          const wrap = document.createElement('div'); wrap.className = 'item';
          if (f.name && /\.(jpe?g|png|gif|webp|svg|bmp)$/i.test(f.name)) {
            const img = document.createElement('img'); img.src = f.url; wrap.appendChild(img);
          } else if (f.name && /\.(mp3|wav|ogg|m4a)$/i.test(f.name)) {
            const a = document.createElement('audio'); a.controls = true; a.src = f.url; wrap.appendChild(a);
          } else {
            const a = document.createElement('a'); a.href = f.url; a.textContent = f.name || f.url; a.target = '_blank'; wrap.appendChild(a);
          }

          const meta = document.createElement('div'); meta.className = 'meta';
          const dl = document.createElement('a'); dl.href = f.url; dl.download = f.name || '';
          dl.textContent = 'Download';
          meta.appendChild(document.createTextNode((f.name ? f.name + ' ' : '') + '(' + (f.url || '') + ') '));
          meta.appendChild(dl);
          wrap.appendChild(meta);
          content.appendChild(wrap);
        }
      } else {
        content.innerHTML = '<p>No files in share.</p>';
      }
    })();
  </script>
</body>
</html>
